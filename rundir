#!/bin/sh
# vim: set fdm=marker:

# rundir
# ======
# 
# An application directory <https://en.wikipedia.org/wiki/Application_directory>
# implementation that also allows for creating self-running archives of
# application directories.
# 
# Copyright (c) 2014 Scott Zeid <s@zeid.me>.
# Released under the X11 License:  <https://tldrlegal.com/license/x11-license>
# 
# Application directory structure:
# 
# - app-dir/
#     - `bin/` - (optional) this is prepended to the executable's $PATH
#     - `<the actual executable; see below for valid filenames>`
#     - `<anything else you want to include>`
# 
# The file to be run will be the first one of the following, in the order
# listed, that is found to exist:
# 
# - `run-here`
# - `run`
# - `run-here.mk`
# - `run.mk`
# - `AppRun` (for ROX compatibility) ($PATH will not be modified)
# 
# The `-here` variants will be executed in the application directory; the other
# ones will be run in the original working directory.
# 
# The `.mk` variants will be treated as makefiles, with the default target
# being `default` instead of `all` (only the first argument is looked at for
# a target name).  Make will also be passed the `-B` (`--always-make`) option.
# 
# Unless otherwise noted, `<application-directory>/bin`, if it exists, will be
# prepended to the $PATH passed to the script/makefile.
# 
# Only the non-makefile variants need to have their executable bits set, and
# only one variant needs to exist.  If multiple variants exist, only the first
# one in the order listed above will be run.
#
# Except for determining the make target name for `run*.mk` files, arguments
# are not treated specially.
# 
# Self-extracting archives
# ------------------------
# 
# This is also capable of producing self-extracting archives.  The default
# behavior of these archives is to extract them to a temporary directory,
# run their contents, and then delete the temporary directory.  They accept
# a few environment variables that will cancel the default behavior:
#
# - `RUNDIR_SFX_EXTRACT=<dirname>`:  extract to `<directory>`
# - `RUNDIR_SFX_LIST=1|true`:  list the archive's contents
# - `RUNDIR_SFX_CAT=1|true`:  dump the archive to stdout
# - `RUNDIR_SFX_HELP=1|true`:  print this usage message
# - `RUNDIR_SFX_USAGE=1|true`:  print this usage message
# 
# and one that doesn't:
# 
# - RUNDIR_SFX_TMP=<directory>:  use `<directory>` instead of `/tmp`
# 
# The SFX archives are shell scripts with a GZIP-compressed TAR archive
# appended after a marker line (`__ARCHIVE_FOLLOWS_IF_SFX__`).
# 
# Usage
# -----
# 
# Run `rundir --help` for command-line usage information that should now be
# self-explanatory.

#### Plumbing

SCRIPT=$0
IS_SFX=0

if [ $IS_SFX -eq 0 -a "$1" = "--" ]; then
 shift
 DASH_DASH=1
else
 DASH_DASH=0
fi

# Entry point (when IS_SFX=0) {{{1

main() {
 if [ $DASH_DASH -eq 0 -a $IS_SFX -eq 0 ]; then
  if [ "$1" = "--search-path" -o "$1" = "-p" ]; then
   shift
   run_in_path "$@"
  elif [ "$1" = "--make-sfx" ]; then
   shift
   make_sfx "$@"
  elif [ "$1" = "--help" -o "$1" = "-h" ]; then
   shift
   usage "$@"
  else
   default "$@"
  fi
 else
  default "$@"
 fi
}

default() {
 if [ -n "$1" ]; then
  local dir=$1
  shift
 else
  usage >&2
  return 2
 fi
 
 run "$dir" "$@"
}

# Usage {{{1

usage() {
 if [ $IS_SFX -eq 1 ]; then
  DIR_ARG=''
 else
  DIR_ARG='<directory> '
 fi
 if [ $IS_SFX -eq 1 ]; then
  echo "Usage: $SCRIPT [args [...]]"
  echo "The default behavior is to extract this archive to a temporary directory,"
  echo "run its contents, and then delete the temporary directory."
  echo
  echo "SFX environment variables..."
  echo " ... that cancel the default behavior:"
  echo "  RUNDIR_SFX_EXTRACT=<directory>:  extract to <directory>"
  echo "  RUNDIR_SFX_LIST=1|true:  list the archive's contents"
  echo "  RUNDIR_SFX_CAT=1|true:  dump the archive to stdout"
  echo "  RUNDIR_SFX_HELP=1|true:  print this usage message"
  echo "  RUNDIR_SFX_USAGE=1|true:  print this usage message"
  echo " ... that don't cancel the default behavior:"
  echo "  RUNDIR_SFX_TMP=<directory>:  use <directory> instead of /tmp"
 else
  echo "Usage: $SCRIPT <directory> [args [...]]"
  echo "       $SCRIPT -p|--search-path <directory-in-path> [args [...]]"
  echo "       $SCRIPT --make-sfx <directory> <output-file>"
  echo "       $SCRIPT -h|--help"
 fi
}

# Running directories {{{1

run() {
 local dir=$1
 shift
 
 cd "$dir"
 if [ $? -ne 0 ]; then
  echo "$0: error: could not enter $dir" >&2
  return 127
 fi
 
 local use_make=0
 local add_path=1
 local path=$PATH
 local run=
 local wd=
 
 if [ -e "run-here" ]; then
  run="run-here"
  wd=$(pwd)
 elif [ -e "run" ]; then
  run="run"
 elif [ -e "run-here.mk" ]; then
  run="run-here.mk"
  wd=$(pwd)
  use_make=1
 elif [ -e "run.mk" ]; then
  run="run.mk"
  use_make=1
 elif [ -e "AppRun" ]; then
  run="AppRun"
  add_path=0
 else
  echo "$SCRIPT: no run-here, run, run-here.mk, or run.mk in $dir" >&2
  return 127
 fi
 run=$(pwd)/"$run"
 
 if [ $add_path -ne 0 -a -d "$(pwd)/bin" ]; then
  path="$(pwd)/bin:$PATH"
 fi
 
 if [ -z "$wd" ]; then
  cd "$OLDPWD"
 fi
 
 if [ $use_make -eq 0 ]; then
  PATH=$path "$run" "$@"
 else
  local target=
  if [ -n "$1" \
       -a -n "$(printf '%s' "$1" | grep -v -e '^-')" \
       -a -n "$(printf '%s' "$1" | grep -v -e '=')" ]; then
   target=$1
   shift
  else
   target=default
  fi
  PATH=$path make -B -f "$run" "$target" "$@"
 fi
}

is_runnable() {
 if [ -z "$1" ]; then
  echo "$SCRIPT:is_runnable: first argument must be the directory" >&2
  return 127
 fi
 
 local dir=$1
 shift
 
 #cd "$dir" &>/dev/null
 #[ $? -ne 0 ] && return 1
 #cd "$OLDPWD"
 [ ! -d "$dir" ] && return 1
 [ -x "$dir/run-here" ] && return 0
 [ -x "$dir/run" ] && return 0
 [ -f "$dir/run-here.mk" ] && return 0
 [ -f "$dir/run.mk" ] && return 0
 return 1
}

run_in_path() {
 local dir=$1
 shift
 
 local resolved=$(resolve_path "$dir")
 if [ -n "$resolved" ]; then
  run "$resolved" "$@"
 else
  echo "$SCRIPT: no runnable $dir in $PATH" >&2
  return 127
 fi
}

resolve_path() {
 local dir=$(basename "$1")
 shift
 
 #local search=$PATH:
 #while [ -n "$search" ]; do
 # local i=${search%%:*}
 # local search=${search#*:}
 local oldifs=$IFS
 IFS=:
 for i in $PATH; do
  if is_runnable "$i/$dir"; then
   echo "$i/$dir"
   IFS=$oldifs
   return 0
  fi
 done
 IFS=$oldifs
 return 1
}

# SFX stuffs {{{1

make_sfx() {
 if [ -z "$1" -o -z "$2" ]; then
  echo "Usage: $SCRIPT --$0 <directory> <output-file>"
  return 2
 fi
 
 local in_dir=$1
 local in_name=$(basename "$in_dir")
 local out_file=$2
 
 if [ ! -d "$in_dir" ]; then
  echo "$0: error: $in_dir is not a directory or a link to one" >&2
  return 2
 fi
 
 cat "$0" \
  | sed -e 's/^IS_SFX=0$/IS_SFX=1/g' \
  > "$out_file"
 tar cz -C "$in_dir" . >> "$out_file"
 chmod +x "$out_file"
}

sfx_entry() {
 local dir=$1
 shift
 
 # The tar archive starts after the __ARCHIVE_FOLLOWS_IF_SFX__ line in the
 # compiled SFX
 local skip=`awk '/^__ARCHIVE_FOLLOWS_IF_SFX__/ { print NR + 1; exit 0; }' \$0`
 
 # Extract, cat, or print help, and then exit, if requested
 if [ -n "$RUNDIR_SFX_EXTRACT" ]; then
  sfx_extract "$skip" "$RUNDIR_SFX_EXTRACT"
  return $?
 elif [ "$RUNDIR_SFX_LIST" = "1" -o "$RUNDIR_SFX_LIST" = "true" ]; then
  sfx_cat "$skip" | tar tz
  return $?
 elif [ "$RUNDIR_SFX_CAT" = "1" -o "$RUNDIR_SFX_CAT" = "true" ]; then
  sfx_cat "$skip"
  return $?
 elif [ "$RUNDIR_SFX_HELP"  = "1" -o "$RUNDIR_SFX_HELP" = "true" -o \
        "$RUNDIR_SFX_USAGE" = "1" -o "$RUNDIR_SFX_USAGE" = "true" ]; then
  usage "$@"
  return $?
 fi
 
 # Determine where to put the temporary directory
 local tmp="/tmp"
 if [ -n "$RUNDIR_SFX_TMP" ]; then
  cd "$RUNDIR_SFX_TMP"
  tmp=$(pwd)
  cd "$OLDPWD"
 fi
 
 # Extract temporary files
 local sfx_tmp="$tmp/rundir-sfx-$$"
 mkdir "$sfx_tmp"
 mkdir "$sfx_tmp/$dir"
 sfx_extract "$skip" "$sfx_tmp/$dir"

 # Allow us to clean up on Ctrl-C
 trap true INT
 
 main "$sfx_tmp/$dir" "$@"
 local ret=$?
 
 # Remove temporary files
 rm -r "$sfx_tmp"

 return $ret
}

sfx_extract() {
 # The archive's offset is really the first argument, but we hide that
 # from the user
 local skip=$1
 shift
 
 if [ -z "$1" ]; then
  echo "Usage: RUNDIR_SFX_EXTRACT=1|true $SCRIPT <output-directory>"
  return 2
 fi
 
 local out=$1
 mkdir -p "$out"
 sfx_cat "$skip" | tar xz -C "$out"
}

sfx_cat() {
 # The archive's offset is really the first argument, but we hide that
 # from the user
 local skip=$1
 shift
 
 tail -n "+$skip" "$SCRIPT"
}

#}}}

if [ $IS_SFX -eq 0 ]; then
 main "$@"
else
 sfx_entry "run.me" "$@"
fi

# Exit so that, if this is an SFX, the archive isn't treated as code
exit $?

# In the compiled SFX, the archive will begin after this line
__ARCHIVE_FOLLOWS_IF_SFX__
