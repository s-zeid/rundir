#!/bin/sh
# vim: set fdm=marker:

# rundir
# ======
# 
# An application directory <https://en.wikipedia.org/wiki/Application_directory>
# implementation that also allows for creating self-running archives of
# application directories.
# 
# Copyright (c) 2014 Scott Zeid <s@zeid.me>.
# Released under the X11 License:  <https://tldrlegal.com/license/x11-license>
# 
# Application directory structure:
# 
# - app-dir/
#     - `bin/` - (optional) this is prepended to the executable's $PATH
#     - `<the actual executable; see below for valid filenames>`
#     - `<anything else you want to include>`
# 
# The file to be run will be the first one of the following, in the order
# listed, that is found to exist:
# 
# - `run-here`
# - `run`
# - `run-here.mk`
# - `run.mk`
# - `AppRun` (for ROX compatibility) ($PATH will not be modified)
# 
# The `-here` variants will be executed in the application directory; the other
# ones will be run in the original working directory.
# 
# The `.mk` variants will be treated as makefiles, with the default target
# being `default` instead of `all` (only the first argument is looked at for
# a target name).  Make will also be passed the `-B` (`--always-make`) option.
# 
# Unless otherwise noted, `<application-directory>/bin`, if it exists, will be
# prepended to the $PATH passed to the script/makefile.
# 
# Only the non-makefile variants need to have their executable bits set, and
# only one variant needs to exist.  If multiple variants exist, only the first
# one in the order listed above will be run.
# 
# Except for determining the make target name for `run*.mk` files, arguments
# are not treated specially.
# 
# `rundir` will fail if the executable file or makefile's owner is not the
# same as the directory's owner, or (if it is a directory) `<dir>/bin`'s
# owner is not the same as the directory's owner.  This prevents attacks
# such as dropping a `run.mk` file in `/tmp` and then tricking a system
# administrator to run `rundir /tmp` as root (e.g. by making a symlink to
# `/tmp` with an innocuous-looking name), or tricking any user to run
# `/tmp` in a file browser that supports using rundir to run runnable
# directories.  In this example, `/tmp` is an arbitrary, but world-writable,
# directory.  (When checking the owners of symlinks, rundir looks at the
# owners of the symlinks themselves, not those of their targets.)
# 
# 
# Self-extracting archives
# ------------------------
# 
# This is also capable of producing self-extracting archives.  The default
# behavior of these archives is to extract them to a temporary directory,
# run their contents, and then delete the temporary directory.  They accept
# a few environment variables that will cancel the default behavior:
# 
# - `RUNDIR_SFX_EXTRACT=<dirname>`:  extract to `<directory>`
# - `RUNDIR_SFX_LIST=1|true`:  list the archive's contents
# - `RUNDIR_SFX_CAT=1|true`:  dump the archive to stdout
# - `RUNDIR_SFX_HELP=1|true`:  print this usage message
# - `RUNDIR_SFX_USAGE=1|true`:  print this usage message
# 
# and one that doesn't:
# 
# - RUNDIR_SFX_TMP=<directory>:  use `<directory>` instead of `/tmp`
# 
# The SFX archives are shell scripts with a GZIP-compressed TAR archive
# appended after a marker line (`__ARCHIVE_FOLLOWS_IF_SFX__`).
# 
# 
# Usage
# -----
# 
# Run `rundir --help` for command-line usage information that should now be
# self-explanatory.
# 
# 
# Portability
# -----------
# 
# This script is intended to be as portable between *nix systems as possible.
# Therefore, an effort has been made to only use POSIX-defined commands,
# POSIX-defined arguments to those commands, and POSIX-defined shell features.
# The only exception is `tar`, but that is only used in the self-extracting
# archive code.
# 
# Contributions to this script are welcome if and only if they meet those
# criteria.
# 
# Also, this is written as a shell script and not in C/C++ because it is
# intended to be portable across processor architectures *without* the need
# to compile code.
# 
# Although this script is written to be portable, the same, however, is not
# necessarily true for runnable directories themselves, obviously.  Authors
# of runnable directories should take care to account for differences between
# *nix systems and processor architectures.


#### Plumbing

SCRIPT=$0
IS_SFX=0

if [ $IS_SFX -eq 0 -a "$1" = "--" ]; then
 shift
 DASH_DASH=1
else
 DASH_DASH=0
fi

# Entry point (when IS_SFX=0) {{{1

main() {
 if [ $DASH_DASH -eq 0 -a $IS_SFX -eq 0 ]; then
  if [ "$1" = "--search-path" -o "$1" = "-p" ]; then
   shift
   run_in_path "$@"
  elif [ "$1" = "--make-sfx" ]; then
   shift
   make_sfx "$@"
  elif [ "$1" = "--help" -o "$1" = "-h" ]; then
   shift
   usage "$@"
  else
   default "$@"
  fi
 else
  default "$@"
 fi
}

default() {
 if [ -n "$1" ]; then
  local dir=$1
  shift
 else
  usage >&2
  return 2
 fi
 
 run_dir "$dir" "$@"
}

# Usage {{{1

usage() {
 if [ $IS_SFX -eq 1 ]; then
  DIR_ARG=''
 else
  DIR_ARG='<directory> '
 fi
 if [ $IS_SFX -eq 1 ]; then
  echo "Usage: $SCRIPT [args [...]]"
  echo "The default behavior is to extract this archive to a temporary directory,"
  echo "run its contents, and then delete the temporary directory."
  echo
  echo "SFX environment variables..."
  echo " ... that cancel the default behavior:"
  echo "  RUNDIR_SFX_EXTRACT=<directory>:  extract to <directory>"
  echo "  RUNDIR_SFX_LIST=1|true:  list the archive's contents"
  echo "  RUNDIR_SFX_CAT=1|true:  dump the archive to stdout"
  echo "  RUNDIR_SFX_HELP=1|true:  print this usage message"
  echo "  RUNDIR_SFX_USAGE=1|true:  print this usage message"
  echo " ... that don't cancel the default behavior:"
  echo "  RUNDIR_SFX_TMP=<directory>:  use <directory> instead of /tmp"
 else
  echo "Usage: $SCRIPT <directory> [args [...]]"
  echo "       $SCRIPT -p|--search-path <directory-in-path> [args [...]]"
  echo "       $SCRIPT --make-sfx <directory> <output-file>"
  echo "       $SCRIPT -h|--help"
 fi
}

# Running directories {{{1

run_dir() {
 local dir=$1
 shift
 
 local dir_name=$dir
 
 local dir_uid=$(get_uid "$dir")
 local run_uid=
 local bin_uid=
 
 # The directory's UID needs to be known for security reasons
 if [ -z "$dir_uid" ]; then
  echo "$SCRIPT: error: could not get $dir's owner"
  return 127
 fi
 
 cd "$dir"
 if [ $? -ne 0 ]; then
  echo "$0: error: could not enter $dir" >&2
  return 127
 fi
 
 local use_make=0
 local add_path=1
 local path=$PATH
 local run_name=
 local run=
 local bin=
 local wd=
 
 if [ -e "run-here" ]; then
  run_name="run-here"
  wd=$(pwd)
 elif [ -e "run" ]; then
  run_name="run"
 elif [ -e "run-here.mk" ]; then
  run_name="run-here.mk"
  wd=$(pwd)
  use_make=1
 elif [ -e "run.mk" ]; then
  run_name="run.mk"
  use_make=1
 elif [ -e "AppRun" ]; then
  run_name="AppRun"
  add_path=0
 else
  echo "$SCRIPT: no run-here, run, run-here.mk, run.mk, or AppRun in $dir" >&2
  return 127
 fi
 run="$(pwd)/$run_name"
 # $run's owner must match that of $dir for security reasons
 run_uid=$(get_uid "$run")
 if [ -z "$run_uid" ]; then
  echo "$SCRIPT: error: could not get $dir_name/$run_name's owner" >&2
  return 127
 elif [ $run_uid -ne $dir_uid ]; then
  echo "$SCRIPT: error: $dir_name/$run_name's owner does not match" \
       "that of $dir_name" >&2
  return 127
 fi
 
 bin="$(pwd)/bin"
 if [ $add_path -ne 0 -a -d "$bin" ]; then
  # $bin's owner must match that of $dir for security reasons
  bin_uid=$(get_uid "$bin")
  if [ -z "$bin_uid" ]; then
   echo "$SCRIPT: error: could not get $dir_name/bin's owner" >&2
   return 127
  elif [ $bin_uid -ne $dir_uid ]; then
   echo "$SCRIPT: error: $dir_name/bin's owner does not match" \
        "that of $dir_name" >&2
   return 127
  else
   path="$(pwd)/bin:$PATH"
  fi
 fi
 
 if [ -z "$wd" ]; then
  cd "$OLDPWD"
 fi
 
 if [ $use_make -eq 0 ]; then
  PATH=$path "$run" "$@"
 else
  local target=
  if [ -n "$1" \
       -a -n "$(printf '%s' "$1" | grep -v -e '^-')" \
       -a -n "$(printf '%s' "$1" | grep -v -e '=')" ]; then
   target=$1
   shift
  else
   target=default
  fi
  PATH=$path make -B -f "$run" "$target" "$@"
 fi
}

is_runnable_dir() {
 if [ -z "$1" ]; then
  echo "$SCRIPT:is_runnable_dir: first argument must be the directory" >&2
  return 127
 fi
 
 local dir=$1
 shift
 
 #cd "$dir" &>/dev/null
 #[ $? -ne 0 ] && return 1
 #cd "$OLDPWD"
 [ ! -d "$dir" ] && return 1
 [ -x "$dir/run-here" ] && return 0
 [ -x "$dir/run" ] && return 0
 [ -f "$dir/run-here.mk" ] && return 0
 [ -f "$dir/run.mk" ] && return 0
 [ -x "$dir/AppRun" ] && return 0
 return 1
}

run_in_path() {
 local dir=$1
 shift
 
 local resolved=$(resolve_path "$dir")
 if [ -n "$resolved" ]; then
  run_dir "$resolved" "$@"
 else
  echo "$SCRIPT: no runnable $dir in $PATH" >&2
  return 127
 fi
}

resolve_path() {
 local dir=$(basename "$1")
 shift
 
 #local search=$PATH:
 #while [ -n "$search" ]; do
 # local i=${search%%:*}
 # local search=${search#*:}
 local oldifs=$IFS
 IFS=:
 for i in $PATH; do
  if is_runnable_dir "$i/$dir"; then
   echo "$i/$dir"
   IFS=$oldifs
   return 0
  fi
 done
 IFS=$oldifs
 return 1
}

# SFX stuffs {{{1

make_sfx() {
 if [ -z "$1" -o -z "$2" ]; then
  echo "Usage: $SCRIPT --$0 <directory> <output-file>"
  return 2
 fi
 
 local in_dir=$1
 local in_name=$(basename "$in_dir")
 local out_file=$2
 
 if [ ! -d "$in_dir" ]; then
  echo "$0: error: $in_dir is not a directory or a link to one" >&2
  return 2
 fi
 
 cat "$0" \
  | sed -e 's/^IS_SFX=0$/IS_SFX=1/g' \
  > "$out_file"
 tar cz -C "$in_dir" . >> "$out_file"
 chmod +x "$out_file"
}

sfx_entry() {
 local dir=$1
 shift
 
 # The tar archive starts after the __ARCHIVE_FOLLOWS_IF_SFX__ line in the
 # compiled SFX
 local skip=`awk '/^__ARCHIVE_FOLLOWS_IF_SFX__/ { print NR + 1; exit 0; }' \$0`
 
 # Extract, cat, or print help, and then exit, if requested
 if [ -n "$RUNDIR_SFX_EXTRACT" ]; then
  sfx_extract "$skip" "$RUNDIR_SFX_EXTRACT"
  return $?
 elif [ "$RUNDIR_SFX_LIST" = "1" -o "$RUNDIR_SFX_LIST" = "true" ]; then
  sfx_cat "$skip" | tar tz
  return $?
 elif [ "$RUNDIR_SFX_CAT" = "1" -o "$RUNDIR_SFX_CAT" = "true" ]; then
  sfx_cat "$skip"
  return $?
 elif [ "$RUNDIR_SFX_HELP"  = "1" -o "$RUNDIR_SFX_HELP" = "true" -o \
        "$RUNDIR_SFX_USAGE" = "1" -o "$RUNDIR_SFX_USAGE" = "true" ]; then
  usage "$@"
  return $?
 fi
 
 # Determine where to put the temporary directory
 local tmp="/tmp"
 if [ -n "$RUNDIR_SFX_TMP" ]; then
  cd "$RUNDIR_SFX_TMP"
  tmp=$(pwd)
  cd "$OLDPWD"
 fi
 
 # Extract temporary files
 local sfx_tmp="$tmp/rundir-sfx-$$"
 mkdir "$sfx_tmp"
 mkdir "$sfx_tmp/$dir"
 sfx_extract "$skip" "$sfx_tmp/$dir"

 # Allow us to clean up on Ctrl-C
 trap true INT
 
 main "$sfx_tmp/$dir" "$@"
 local ret=$?
 
 # Remove temporary files
 rm -r "$sfx_tmp"

 return $ret
}

sfx_extract() {
 # The archive's offset is really the first argument, but we hide that
 # from the user
 local skip=$1
 shift
 
 if [ -z "$1" ]; then
  echo "Usage: RUNDIR_SFX_EXTRACT=1|true $SCRIPT <output-directory>"
  return 2
 fi
 
 local out=$1
 mkdir -p "$out"
 sfx_cat "$skip" | tar xz -C "$out"
}

sfx_cat() {
 # The archive's offset is really the first argument, but we hide that
 # from the user
 local skip=$1
 shift
 
 tail -n "+$skip" "$SCRIPT"
}

# Utilities {{{1

# This (obviously) gets the user ID of the given file/directory's owner.
# For symlinks, it looks at the owner of the symlink itself.
# Unfortunately, in order to be portable, this has to parse the output of
# `ls -d -n "$file"`, but the format of `ls -n` (like `ls -l`, but prints
# numeric IDs instead of names) is defined by POSIX, so we rely on the
# implementation being conformant.
get_uid() {
 if [ -z "$1" ]; then
  echo "$SCRIPT:get_uid: first argument must be a path" >&2
  return 127
 fi
 
 local file=$1
 shift
 
 # Try to ensure `ls` will succeed
 ls -d -n "$file" >/dev/null
 if [ $? -ne 0 ]; then
  echo "$SCRIPT:get_uid: could not get information for $file" &>2
  return 127
 fi
 
 local uid=$(ls -d -n "$file" | sed -e "s/\t/ /g" | cut -d ' ' -f 3)
 
 # The UID should be an integer; otherwise, we've failed
 echo "x$uid" | grep -v '^x[0-9][0-9]*$' &>/dev/null
 if [ $? -eq 0 ]; then
  echo "$SCRIPT:get_uid: could not determine the owner's UID for $file" >&2
  return 127
 fi
 
 echo "$uid"
}

#}}}

if [ $IS_SFX -eq 0 ]; then
 main "$@"
else
 sfx_entry "run.me" "$@"
fi

# Exit so that, if this is an SFX, the archive isn't treated as code
exit $?

# In the compiled SFX, the archive will begin after this line
__ARCHIVE_FOLLOWS_IF_SFX__
